#!/usr/bin/env bash

# Crash script on errors.
set -e

# Ignore signal in top script.
trap '' SIGTERM

# Create array to store processes.
declare -A process_list

# Evaluate config to get $PORT to attach to.
erb config/nginx.conf.erb > config/nginx.conf

n=1
while getopts :f option ${@:1:2}
do
  case "${option}"
  in
    f) FORCE=$OPTIND; n=$((n+1));;
  esac
done

# Initialize log directory.
mkdir -p logs/nginx
touch logs/nginx/access.log logs/nginx/error.log
echo 'buildpack=nginx at=logs-initialized'

# Start server.
(
  # Take the command passed to this bin and start it.
  # E.g. bin/start-nginx bundle exec unicorn -c config/unicorn.rb
  COMMAND=${@:$n}
  echo "buildpack=nginx at=start-app cmd=$COMMAND"
  $COMMAND
  echo 'Server terminated!'
) &
process_list[server]=$!

# Start log redirection.
(
  # Redirect nginx logs to stdout.
  tail -qF -n 0 --pid=${process_list[server]} logs/nginx/*.log
  echo 'Tail terminated!'
) &
process_list[tail]=$!

if [[ -z "$FORCE" ]]
then
  FILE="/tmp/app-initialized"

  # We block on app-initialized so that when nginx binds to $PORT
  # app is ready for traffic.
  while [[ ! -f "$FILE" ]]
  do
    echo 'buildpack=nginx at=app-initialization'
    sleep 1
  done
  echo 'buildpack=nginx at=app-initialized'
fi

# Start nginx.
(
  # We expect nginx to run in foreground.
  # We also expect a socket to be at /tmp/nginx.socket.
  echo 'buildpack=nginx at=nginx-start'
  bin/nginx -p . -c config/nginx.conf
  echo 'Nginx terminated!'
) &
process_list[nginx]=$!

# Wait for everything to finish before exiting.
wait "${process_list[@]}"
echo 'Bye!'
